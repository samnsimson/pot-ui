/* tslint:disable */
/* eslint-disable */
/**
 * PotCMS
 * A key value store to manage your content
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AppCreateSchema
 */
export interface AppCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof AppCreateSchema
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AppDeleteOutSchema
 */
export interface AppDeleteOutSchema {
    /**
     * 
     * @type {string}
     * @memberof AppDeleteOutSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AppDeleteOutSchema
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface AppOutSchema
 */
export interface AppOutSchema {
    /**
     * 
     * @type {string}
     * @memberof AppOutSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AppOutSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AppOutSchema
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof AppOutSchema
     */
    'secret': string;
    /**
     * 
     * @type {boolean}
     * @memberof AppOutSchema
     */
    'is_active': boolean;
    /**
     * 
     * @type {string}
     * @memberof AppOutSchema
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof AppOutSchema
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface AuthResponseSchema
 */
export interface AuthResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSchema
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSchema
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSchema
     */
    'host': string;
    /**
     * 
     * @type {RoleEnum}
     * @memberof AuthResponseSchema
     */
    'role': RoleEnum;
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSchema
     */
    'redirect_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSchema
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSchema
     */
    'refresh_token': string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSchema
     */
    'token_type': string;
    /**
     * 
     * @type {number}
     * @memberof AuthResponseSchema
     */
    'token_max_age': number;
}


/**
 * 
 * @export
 * @interface ContentCreateSchema
 */
export interface ContentCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof ContentCreateSchema
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof ContentCreateSchema
     */
    'data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ContentCreateSchema
     */
    'parent_id'?: string | null;
}
/**
 * 
 * @export
 * @interface ContentOutSchema
 */
export interface ContentOutSchema {
    /**
     * 
     * @type {string}
     * @memberof ContentOutSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContentOutSchema
     */
    'app_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContentOutSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContentOutSchema
     */
    'slug': string;
    /**
     * 
     * @type {object}
     * @memberof ContentOutSchema
     */
    'data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ContentOutSchema
     */
    'parent_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContentOutSchema
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ContentOutSchema
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<ContentOutSchema>}
     * @memberof ContentOutSchema
     */
    'children'?: Array<ContentOutSchema>;
}
/**
 * 
 * @export
 * @interface ContentUpdateSchema
 */
export interface ContentUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof ContentUpdateSchema
     */
    'name'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof ContentUpdateSchema
     */
    'data'?: object | null;
}
/**
 * 
 * @export
 * @interface DomainCreateSchema
 */
export interface DomainCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof DomainCreateSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DomainCreateSchema
     */
    'host': string;
}
/**
 * 
 * @export
 * @interface DomainOutSchema
 */
export interface DomainOutSchema {
    /**
     * 
     * @type {string}
     * @memberof DomainOutSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DomainOutSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DomainOutSchema
     */
    'host': string;
    /**
     * 
     * @type {string}
     * @memberof DomainOutSchema
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DomainOutSchema
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Key
 */
export interface Key {
}
/**
 * 
 * @export
 * @interface MediaResponse
 */
export interface MediaResponse {
    /**
     * 
     * @type {string}
     * @memberof MediaResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponse
     */
    'media_type': string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponse
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaResponse
     */
    'alt_text': string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaResponse
     */
    'caption': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaResponse
     */
    'is_public': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MediaTypeEnum = {
    Image: 'image',
    Video: 'video',
    Audio: 'audio',
    Other: 'other'
} as const;

export type MediaTypeEnum = typeof MediaTypeEnum[keyof typeof MediaTypeEnum];


/**
 * 
 * @export
 * @interface MediaUpdateSchema
 */
export interface MediaUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof MediaUpdateSchema
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaUpdateSchema
     */
    'alt_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaUpdateSchema
     */
    'caption'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaUpdateSchema
     */
    'is_public'?: boolean | null;
    /**
     * 
     * @type {object}
     * @memberof MediaUpdateSchema
     */
    'meta'?: object | null;
}
/**
 * 
 * @export
 * @interface RefreshBody
 */
export interface RefreshBody {
    /**
     * 
     * @type {string}
     * @memberof RefreshBody
     */
    'token': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RoleEnum = {
    User: 'user',
    Admin: 'admin',
    SuperAdmin: 'super_admin'
} as const;

export type RoleEnum = typeof RoleEnum[keyof typeof RoleEnum];


/**
 * 
 * @export
 * @interface UserCreateSchema
 */
export interface UserCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof UserCreateSchema
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateSchema
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateSchema
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateSchema
     */
    'password': string;
    /**
     * 
     * @type {DomainCreateSchema}
     * @memberof UserCreateSchema
     */
    'domain': DomainCreateSchema;
}
/**
 * 
 * @export
 * @interface UserOutSchema
 */
export interface UserOutSchema {
    /**
     * 
     * @type {string}
     * @memberof UserOutSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserOutSchema
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserOutSchema
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserOutSchema
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof UserOutSchema
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserOutSchema
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * AppsApi - axios parameter creator
 * @export
 */
export const AppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create App
         * @param {AppCreateSchema} appCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApp: async (appCreateSchema: AppCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appCreateSchema' is not null or undefined
            assertParamExists('createApp', 'appCreateSchema', appCreateSchema)
            const localVarPath = `/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete App
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApp: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApp', 'id', id)
            const localVarPath = `/apps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get App
         * @param {Key} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppByIdOrSlug: async (key: Key, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getAppByIdOrSlug', 'key', key)
            const localVarPath = `/apps/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get App Users
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppUsers: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAppUsers', 'id', id)
            const localVarPath = `/apps/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApps: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 * @export
 */
export const AppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create App
         * @param {AppCreateSchema} appCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApp(appCreateSchema: AppCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApp(appCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.createApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete App
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApp(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppDeleteOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApp(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.deleteApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get App
         * @param {Key} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppByIdOrSlug(key: Key, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppByIdOrSlug(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.getAppByIdOrSlug']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get App Users
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppUsers(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserOutSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppUsers(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.getAppUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApps(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AppOutSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApps(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.listApps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppsApi - factory interface
 * @export
 */
export const AppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create App
         * @param {AppCreateSchema} appCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApp(appCreateSchema: AppCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<AppOutSchema> {
            return localVarFp.createApp(appCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete App
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApp(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AppDeleteOutSchema> {
            return localVarFp.deleteApp(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get App
         * @param {Key} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppByIdOrSlug(key: Key, options?: RawAxiosRequestConfig): AxiosPromise<AppOutSchema> {
            return localVarFp.getAppByIdOrSlug(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get App Users
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppUsers(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserOutSchema>> {
            return localVarFp.getAppUsers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApps(options?: RawAxiosRequestConfig): AxiosPromise<Array<AppOutSchema>> {
            return localVarFp.listApps(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppsApi - interface
 * @export
 * @interface AppsApi
 */
export interface AppsApiInterface {
    /**
     * 
     * @summary Create App
     * @param {AppCreateSchema} appCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApiInterface
     */
    createApp(appCreateSchema: AppCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<AppOutSchema>;

    /**
     * 
     * @summary Delete App
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApiInterface
     */
    deleteApp(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AppDeleteOutSchema>;

    /**
     * 
     * @summary Get App
     * @param {Key} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApiInterface
     */
    getAppByIdOrSlug(key: Key, options?: RawAxiosRequestConfig): AxiosPromise<AppOutSchema>;

    /**
     * 
     * @summary Get App Users
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApiInterface
     */
    getAppUsers(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserOutSchema>>;

    /**
     * 
     * @summary List Apps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApiInterface
     */
    listApps(options?: RawAxiosRequestConfig): AxiosPromise<Array<AppOutSchema>>;

}

/**
 * AppsApi - object-oriented interface
 * @export
 * @class AppsApi
 * @extends {BaseAPI}
 */
export class AppsApi extends BaseAPI implements AppsApiInterface {
    /**
     * 
     * @summary Create App
     * @param {AppCreateSchema} appCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public createApp(appCreateSchema: AppCreateSchema, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).createApp(appCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete App
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public deleteApp(id: string, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).deleteApp(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get App
     * @param {Key} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public getAppByIdOrSlug(key: Key, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).getAppByIdOrSlug(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get App Users
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public getAppUsers(id: string, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).getAppUsers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Apps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public listApps(options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).listApps(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('login', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('login', 'password', password)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Token
         * @param {RefreshBody} refreshBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshBody: RefreshBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshBody' is not null or undefined
            assertParamExists('refreshToken', 'refreshBody', refreshBody)
            const localVarPath = `/auth/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register
         * @param {UserCreateSchema} userCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (userCreateSchema: UserCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateSchema' is not null or undefined
            assertParamExists('signup', 'userCreateSchema', userCreateSchema)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(username, password, grantType, scope, clientId, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh Token
         * @param {RefreshBody} refreshBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshBody: RefreshBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register
         * @param {UserCreateSchema} userCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(userCreateSchema: UserCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(userCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.signup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponseSchema> {
            return localVarFp.login(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Token
         * @param {RefreshBody} refreshBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshBody: RefreshBody, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponseSchema> {
            return localVarFp.refreshToken(refreshBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register
         * @param {UserCreateSchema} userCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(userCreateSchema: UserCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<UserOutSchema> {
            return localVarFp.signup(userCreateSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * 
     * @summary Login
     * @param {string} username 
     * @param {string} password 
     * @param {string | null} [grantType] 
     * @param {string} [scope] 
     * @param {string | null} [clientId] 
     * @param {string | null} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    login(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponseSchema>;

    /**
     * 
     * @summary Refresh Token
     * @param {RefreshBody} refreshBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    refreshToken(refreshBody: RefreshBody, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponseSchema>;

    /**
     * 
     * @summary Register
     * @param {UserCreateSchema} userCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    signup(userCreateSchema: UserCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<UserOutSchema>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * 
     * @summary Login
     * @param {string} username 
     * @param {string} password 
     * @param {string | null} [grantType] 
     * @param {string} [scope] 
     * @param {string | null} [clientId] 
     * @param {string | null} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Token
     * @param {RefreshBody} refreshBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(refreshBody: RefreshBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(refreshBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register
     * @param {UserCreateSchema} userCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signup(userCreateSchema: UserCreateSchema, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signup(userCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Content
         * @param {string} appId 
         * @param {ContentCreateSchema} contentCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContent: async (appId: string, contentCreateSchema: ContentCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createContent', 'appId', appId)
            // verify required parameter 'contentCreateSchema' is not null or undefined
            assertParamExists('createContent', 'contentCreateSchema', contentCreateSchema)
            const localVarPath = `/content/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contentCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Content
         * @param {string} appId 
         * @param {string} contentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContent: async (appId: string, contentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('exportContent', 'appId', appId)
            // verify required parameter 'contentId' is not null or undefined
            assertParamExists('exportContent', 'contentId', contentId)
            const localVarPath = `/content/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (appId !== undefined) {
                localVarQueryParameter['app_id'] = appId;
            }

            if (contentId !== undefined) {
                localVarQueryParameter['content_id'] = contentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Content
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent: async (appId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getContent', 'appId', appId)
            const localVarPath = `/content/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Content
         * @param {string} appId 
         * @param {string} contentId 
         * @param {ContentUpdateSchema} contentUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContent: async (appId: string, contentId: string, contentUpdateSchema: ContentUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateContent', 'appId', appId)
            // verify required parameter 'contentId' is not null or undefined
            assertParamExists('updateContent', 'contentId', contentId)
            // verify required parameter 'contentUpdateSchema' is not null or undefined
            assertParamExists('updateContent', 'contentUpdateSchema', contentUpdateSchema)
            const localVarPath = `/content`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (appId !== undefined) {
                localVarQueryParameter['app_id'] = appId;
            }

            if (contentId !== undefined) {
                localVarQueryParameter['content_id'] = contentId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contentUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Content
         * @param {string} appId 
         * @param {ContentCreateSchema} contentCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContent(appId: string, contentCreateSchema: ContentCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContent(appId, contentCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.createContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Export Content
         * @param {string} appId 
         * @param {string} contentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportContent(appId: string, contentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportContent(appId, contentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.exportContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Content
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContent(appId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContentOutSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContent(appId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.getContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Content
         * @param {string} appId 
         * @param {string} contentId 
         * @param {ContentUpdateSchema} contentUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContent(appId: string, contentId: string, contentUpdateSchema: ContentUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContent(appId, contentId, contentUpdateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.updateContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Content
         * @param {string} appId 
         * @param {ContentCreateSchema} contentCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContent(appId: string, contentCreateSchema: ContentCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<ContentOutSchema> {
            return localVarFp.createContent(appId, contentCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export Content
         * @param {string} appId 
         * @param {string} contentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContent(appId: string, contentId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.exportContent(appId, contentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Content
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent(appId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ContentOutSchema>> {
            return localVarFp.getContent(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Content
         * @param {string} appId 
         * @param {string} contentId 
         * @param {ContentUpdateSchema} contentUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContent(appId: string, contentId: string, contentUpdateSchema: ContentUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<ContentOutSchema> {
            return localVarFp.updateContent(appId, contentId, contentUpdateSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - interface
 * @export
 * @interface ContentApi
 */
export interface ContentApiInterface {
    /**
     * 
     * @summary Create Content
     * @param {string} appId 
     * @param {ContentCreateSchema} contentCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    createContent(appId: string, contentCreateSchema: ContentCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<ContentOutSchema>;

    /**
     * 
     * @summary Export Content
     * @param {string} appId 
     * @param {string} contentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    exportContent(appId: string, contentId: string, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Content
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getContent(appId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ContentOutSchema>>;

    /**
     * 
     * @summary Update Content
     * @param {string} appId 
     * @param {string} contentId 
     * @param {ContentUpdateSchema} contentUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    updateContent(appId: string, contentId: string, contentUpdateSchema: ContentUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<ContentOutSchema>;

}

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI implements ContentApiInterface {
    /**
     * 
     * @summary Create Content
     * @param {string} appId 
     * @param {ContentCreateSchema} contentCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public createContent(appId: string, contentCreateSchema: ContentCreateSchema, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).createContent(appId, contentCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export Content
     * @param {string} appId 
     * @param {string} contentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public exportContent(appId: string, contentId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).exportContent(appId, contentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Content
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getContent(appId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).getContent(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Content
     * @param {string} appId 
     * @param {string} contentId 
     * @param {ContentUpdateSchema} contentUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public updateContent(appId: string, contentId: string, contentUpdateSchema: ContentUpdateSchema, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).updateContent(appId, contentId, contentUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Document
         * @param {string} appId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument: async (appId: string, documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getDocument', 'appId', appId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocument', 'documentId', documentId)
            const localVarPath = `/documents/{app_id}/{document_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Documents
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments: async (appId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listDocuments', 'appId', appId)
            const localVarPath = `/documents/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Document
         * @param {string} appId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocument(appId: string, documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocument(appId, documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.getDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Documents
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocuments(appId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocuments(appId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.listDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Document
         * @param {string} appId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument(appId: string, documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getDocument(appId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Documents
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(appId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listDocuments(appId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - interface
 * @export
 * @interface DocumentsApi
 */
export interface DocumentsApiInterface {
    /**
     * 
     * @summary Get Document
     * @param {string} appId 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    getDocument(appId: string, documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary List Documents
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    listDocuments(appId: string, options?: RawAxiosRequestConfig): AxiosPromise<any>;

}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI implements DocumentsApiInterface {
    /**
     * 
     * @summary Get Document
     * @param {string} appId 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public getDocument(appId: string, documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).getDocument(appId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Documents
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public listDocuments(appId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).listDocuments(appId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainApi - axios parameter creator
 * @export
 */
export const DomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Domain
         * @param {DomainCreateSchema} domainCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: async (domainCreateSchema: DomainCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainCreateSchema' is not null or undefined
            assertParamExists('createDomain', 'domainCreateSchema', domainCreateSchema)
            const localVarPath = `/domain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainApi - functional programming interface
 * @export
 */
export const DomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Domain
         * @param {DomainCreateSchema} domainCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomain(domainCreateSchema: DomainCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomain(domainCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainApi.createDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainApi - factory interface
 * @export
 */
export const DomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Domain
         * @param {DomainCreateSchema} domainCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(domainCreateSchema: DomainCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<DomainOutSchema> {
            return localVarFp.createDomain(domainCreateSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainApi - interface
 * @export
 * @interface DomainApi
 */
export interface DomainApiInterface {
    /**
     * 
     * @summary Create Domain
     * @param {DomainCreateSchema} domainCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    createDomain(domainCreateSchema: DomainCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<DomainOutSchema>;

}

/**
 * DomainApi - object-oriented interface
 * @export
 * @class DomainApi
 * @extends {BaseAPI}
 */
export class DomainApi extends BaseAPI implements DomainApiInterface {
    /**
     * 
     * @summary Create Domain
     * @param {DomainCreateSchema} domainCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public createDomain(domainCreateSchema: DomainCreateSchema, options?: RawAxiosRequestConfig) {
        return DomainApiFp(this.configuration).createDomain(domainCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Media
         * @param {string} appId 
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMedia: async (appId: string, mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteMedia', 'appId', appId)
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('deleteMedia', 'mediaId', mediaId)
            const localVarPath = `/media/{app_id}/{media_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"media_id"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Media
         * @param {string} appId 
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMedia: async (appId: string, mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getMedia', 'appId', appId)
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('getMedia', 'mediaId', mediaId)
            const localVarPath = `/media/{app_id}/{media_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"media_id"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List App Media
         * @param {string} appId 
         * @param {MediaTypeEnum | null} [mediaType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAppMedia: async (appId: string, mediaType?: MediaTypeEnum | null, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listAppMedia', 'appId', appId)
            const localVarPath = `/media/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (mediaType !== undefined) {
                localVarQueryParameter['media_type'] = mediaType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Media
         * @param {string} appId 
         * @param {string} mediaId 
         * @param {MediaUpdateSchema} mediaUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMedia: async (appId: string, mediaId: string, mediaUpdateSchema: MediaUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateMedia', 'appId', appId)
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('updateMedia', 'mediaId', mediaId)
            // verify required parameter 'mediaUpdateSchema' is not null or undefined
            assertParamExists('updateMedia', 'mediaUpdateSchema', mediaUpdateSchema)
            const localVarPath = `/media/{app_id}/{media_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"media_id"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mediaUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Media
         * @param {string} appId 
         * @param {File} file Media file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMedia: async (appId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('uploadMedia', 'appId', appId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadMedia', 'file', file)
            const localVarPath = `/media/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (appId !== undefined) {
                localVarQueryParameter['app_id'] = appId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Media
         * @param {string} appId 
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMedia(appId: string, mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMedia(appId, mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.deleteMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Media
         * @param {string} appId 
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMedia(appId: string, mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMedia(appId, mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List App Media
         * @param {string} appId 
         * @param {MediaTypeEnum | null} [mediaType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAppMedia(appId: string, mediaType?: MediaTypeEnum | null, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MediaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAppMedia(appId, mediaType, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.listAppMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Media
         * @param {string} appId 
         * @param {string} mediaId 
         * @param {MediaUpdateSchema} mediaUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMedia(appId: string, mediaId: string, mediaUpdateSchema: MediaUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMedia(appId, mediaId, mediaUpdateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.updateMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Media
         * @param {string} appId 
         * @param {File} file Media file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMedia(appId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMedia(appId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.uploadMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Media
         * @param {string} appId 
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMedia(appId: string, mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteMedia(appId, mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Media
         * @param {string} appId 
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMedia(appId: string, mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaResponse> {
            return localVarFp.getMedia(appId, mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List App Media
         * @param {string} appId 
         * @param {MediaTypeEnum | null} [mediaType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAppMedia(appId: string, mediaType?: MediaTypeEnum | null, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<MediaResponse>> {
            return localVarFp.listAppMedia(appId, mediaType, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Media
         * @param {string} appId 
         * @param {string} mediaId 
         * @param {MediaUpdateSchema} mediaUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMedia(appId: string, mediaId: string, mediaUpdateSchema: MediaUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<MediaResponse> {
            return localVarFp.updateMedia(appId, mediaId, mediaUpdateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Media
         * @param {string} appId 
         * @param {File} file Media file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMedia(appId: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<MediaResponse> {
            return localVarFp.uploadMedia(appId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - interface
 * @export
 * @interface MediaApi
 */
export interface MediaApiInterface {
    /**
     * 
     * @summary Delete Media
     * @param {string} appId 
     * @param {string} mediaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApiInterface
     */
    deleteMedia(appId: string, mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Media
     * @param {string} appId 
     * @param {string} mediaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApiInterface
     */
    getMedia(appId: string, mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaResponse>;

    /**
     * 
     * @summary List App Media
     * @param {string} appId 
     * @param {MediaTypeEnum | null} [mediaType] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApiInterface
     */
    listAppMedia(appId: string, mediaType?: MediaTypeEnum | null, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<MediaResponse>>;

    /**
     * 
     * @summary Update Media
     * @param {string} appId 
     * @param {string} mediaId 
     * @param {MediaUpdateSchema} mediaUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApiInterface
     */
    updateMedia(appId: string, mediaId: string, mediaUpdateSchema: MediaUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<MediaResponse>;

    /**
     * 
     * @summary Upload Media
     * @param {string} appId 
     * @param {File} file Media file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApiInterface
     */
    uploadMedia(appId: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<MediaResponse>;

}

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI implements MediaApiInterface {
    /**
     * 
     * @summary Delete Media
     * @param {string} appId 
     * @param {string} mediaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public deleteMedia(appId: string, mediaId: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).deleteMedia(appId, mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Media
     * @param {string} appId 
     * @param {string} mediaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getMedia(appId: string, mediaId: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMedia(appId, mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List App Media
     * @param {string} appId 
     * @param {MediaTypeEnum | null} [mediaType] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public listAppMedia(appId: string, mediaType?: MediaTypeEnum | null, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).listAppMedia(appId, mediaType, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Media
     * @param {string} appId 
     * @param {string} mediaId 
     * @param {MediaUpdateSchema} mediaUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public updateMedia(appId: string, mediaId: string, mediaUpdateSchema: MediaUpdateSchema, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).updateMedia(appId, mediaId, mediaUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Media
     * @param {string} appId 
     * @param {File} file Media file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public uploadMedia(appId: string, file: File, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).uploadMedia(appId, file, options).then((request) => request(this.axios, this.basePath));
    }
}



